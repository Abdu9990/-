import requests
import pandas as pd
import numpy as np
import ta.momentum # Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… RSI Ùˆ Stochastic
import ta.trend    # Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… MACD Ùˆ ADX
import ta.volume   # Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… OBV
import ta.volatility # Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… ATR Ùˆ BBands
from scipy.fft import fft
from datetime import datetime

# --- Ø¥Ø¹Ø¯Ø§Ø¯Ø§ØªÙƒ ---
# Finnhub API
FINNHUB_API_KEY = "d16st71r01qkv5jd4pp0d16s1"  # Ù…ÙØªØ§Ø­Ùƒ Ù…Ù† Ø§Ù„ØµÙˆØ±Ø© (ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù†Ù‡ ØµØ­ÙŠØ­ Ù„Ø¯ÙŠÙƒ)
SYMBOL = "AAPL"  # Ø±Ù…Ø² Ø§Ù„Ø³Ù‡Ù… (ÙŠÙ…ÙƒÙ†Ùƒ ØªØºÙŠÙŠØ±Ù‡ Ù„Ø£ÙŠ Ø³Ù‡Ù… Ø£Ùˆ Ù…Ø¤Ø´Ø±)
INTERVAL = "D"   # Ø§Ù„ÙØ§ØµÙ„ Ø§Ù„Ø²Ù…Ù†ÙŠ: "D" ÙŠÙˆÙ…ÙŠØŒ "60" Ù„ÙƒÙ„ Ø³Ø§Ø¹Ø©
LIMIT = 70       # Ø¹Ø¯Ø¯ Ø§Ù„Ø´Ù…ÙˆØ¹ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©

# Telegram
BOT_TOKEN = "7868253928:AAHQ6sKrkdA2VoSm0p_9ZlA6iFGn_TQugBU" # <--- Ù‡Ø°Ø§ Ù‡Ùˆ Ø§Ù„ØªÙˆÙƒÙ† Ø§Ù„ØµØ­ÙŠØ­ Ø§Ù„Ø°ÙŠ Ø²ÙˆØ¯ØªÙ†ÙŠ Ø¨Ù‡
CHAT_ID = "60519721" # ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ù‡Ø°Ø§ Ø§Ù„Ù€ CHAT_ID ØµØ­ÙŠØ­ØŒ ÙˆÙ‡Ùˆ Ù…Ø¹Ø±Ù Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø¥Ù„ÙŠÙ‡Ø§

# --- Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ù…Ù† finnhub ---
def fetch_finnhub_ohlc(symbol, limit=70, interval="D"):
    url = f"https://finnhub.io/api/v1/stock/candle"
    params = {
        "symbol": symbol,
        "resolution": interval,
        "count": limit,
        "token": FINNHUB_API_KEY
    }
    resp = requests.get(url, params=params)
    data = resp.json()
    if data.get('s') != 'ok':
        raise Exception(f"Finnhub Error: {data}")
    df = pd.DataFrame({
        'open': data['o'],
        'high': data['h'],
        'low': data['l'],
        'close': data['c'],
        'volume': data['v']
    })
    return df

# --- Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„ÙÙ†ÙŠØ© ÙˆÙˆØ­Ø¯Ø© Ø§Ù„Ù‚Ø±Ø§Ø± (Ù…Ø¹Ø¯Ù„Ø© Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…ÙƒØªØ¨Ø© 'ta') ---
def indicator_rsi(data):
    if len(data) < 14: return pd.Series([np.nan])
    return ta.momentum.RSIIndicator(data['close'], window=14).rsi()

def indicator_macd(data):
    if len(data) < 26: return pd.Series([np.nan])
    macd = ta.trend.MACD(data['close'], window_fast=12, window_slow=26, window_sign=9).macd()
    return macd

def indicator_obv(data):
    if len(data) < 2: return pd.Series([np.nan])
    return ta.volume.OnBalanceVolumeIndicator(data['close'], data['volume']).on_balance_volume()

def indicator_ema(data, p):
    if len(data) < p: return pd.Series([np.nan])
    return ta.trend.EMAIndicator(data['close'], window=p).ema_indicator()

def indicator_atr(data):
    if len(data) < 14: return pd.Series([np.nan])
    return ta.volatility.AverageTrueRange(data['high'], data['low'], data['close'], window=14).average_true_range()

def indicator_adx(data):
    if len(data) < 14: return pd.Series([np.nan])
    # ADX ÙÙŠ Ù…ÙƒØªØ¨Ø© ta ÙŠØªÙ… Ø­Ø³Ø§Ø¨Ù‡Ø§ Ø¨Ø´ÙƒÙ„ Ù…Ø¨Ø§Ø´Ø±ØŒ Ù„ÙƒÙ† Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù‚ÙŠÙ…Ø© ÙˆØ§Ø­Ø¯Ø© Ù…Ø«Ù„ talibØŒ Ù‚Ø¯ Ù†Ø­ØªØ§Ø¬ Ù„Ø£Ø®Ø° Ø¢Ø®Ø± Ù‚ÙŠÙ…Ø© Ù…Ù† Ø³Ù„Ø³Ù„Ø© Ø§Ù„Ù…Ø¤Ø´Ø±
    return ta.trend.ADXIndicator(data['high'], data['low'], data['close'], window=14).adx()

def indicator_cci(data):
    if len(data) < 20: return pd.Series([np.nan])
    return ta.momentum.CCIIndicator(data['high'], data['low'], data['close'], window=20).cci()

def indicator_bbw(data): # Bollinger Bands Width
    if len(data) < 20: return pd.Series([np.nan])
    bb = ta.volatility.BollingerBands(data['close'], window=20)
    # Ù„Ø­Ø³Ø§Ø¨ Ø¹Ø±Ø¶ Ù†Ø·Ø§Ù‚ Ø¨ÙˆÙ„ÙŠÙ†Ø¬Ø±: (Upper Band - Lower Band) / Middle Band
    return (bb.bollinger_hband() - bb.bollinger_lband()) / bb.bollinger_mavg()

def indicator_vwap(data):
    return (data['close'] * data['volume']).cumsum() / data['volume'].cumsum()

def indicator_market_maker_fingerprint_instant(data):
    if len(data) < 3: return pd.Series([np.nan])
    return ((data['close'] - data['open']) / data['open'] * 100).rolling(window=3).mean()

def indicator_gamma(data):
    if len(data) < 10: return pd.Series([np.nan])
    hl = data['high'] - data['low']
    return (hl / data['close']).rolling(window=10).mean()

def indicator_liquidity(data):
    if len(data) < 5: return pd.Series([np.nan])
    return data['volume'].rolling(window=5).mean()

def indicator_hidden_liquidity(data):
    if len(data) < 5: return pd.Series([np.nan])
    return (data['volume'] * (data['close'] - data['low'])).rolling(window=5).mean()

def indicator_fourier_resonance(data):
    if len(data) < 64: return 0
    prices = data['close'].values[-64:]
    y = fft(prices)
    freqs = np.fft.fftfreq(len(prices))
    dom = freqs[np.argmax(np.abs(y[1:])) + 1]
    return 1 / dom if dom != 0 else 0

def indicator_ema_cross(data):
    if len(data) < 20: return pd.Series([np.nan])
    ema_short = ta.trend.EMAIndicator(data['close'], window=5).ema_indicator()
    ema_long = ta.trend.EMAIndicator(data['close'], window=20).ema_indicator()
    return ema_short - ema_long

def indicator_williams_r(data):
    if len(data) < 14: return pd.Series([np.nan])
    return ta.momentum.WilliamsRIndicator(data['high'], data['low'], data['close'], window=14).williams_r()

def indicator_roc(data):
    if len(data) < 10: return pd.Series([np.nan])
    return ta.momentum.ROCIndicator(data['close'], window=10).roc()

def indicator_stochastic(data):
    if len(data) < 3: return pd.Series([np.nan])
    # ÙÙŠ Ù…ÙƒØªØ¨Ø© taØŒ Ø³ØªØ­ØµÙ„ Ø¹Ù„Ù‰ K Ùˆ D Ù…Ù† Ù†ÙØ³ Ø§Ù„Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ØŒ ÙˆÙŠÙ…ÙƒÙ†Ùƒ Ø·Ø±Ø­Ù‡Ù…Ø§
    stoch_indicator = ta.momentum.StochasticOscillator(data['high'], data['low'], data['close'])
    slowk = stoch_indicator.stoch_signal() # Ø¹Ø§Ø¯Ø©Ù‹ Ù…Ø§ ÙŠÙƒÙˆÙ† Ù‡Ø°Ø§ Ù‡Ùˆ Ø§Ù„Ù€ D
    slowd = stoch_indicator.stoch_percent_k() # ÙˆÙ‡Ø°Ø§ Ù‡Ùˆ Ø§Ù„Ù€ K
    return slowd - slowk # ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„ØµØ­ÙŠØ­ Ù„Ù„Ø·Ø±Ø­ K - D Ø£Ùˆ D - K Ø­Ø³Ø¨ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØªÙƒ

def indicator_turtle_wave(data):
    if len(data) < 20: return pd.Series([np.nan])
    return (data['close'] - data['low']).rolling(window=20).mean()

def decision_engine_full(data):
    if len(data) < 65:
        return "âš  Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ÙƒØ§ÙÙŠØ© Ù„Ù„ØªØ­Ù„ÙŠÙ„!"

    score = 0
    thresholds = {
        'rsi': 70,
        'macd': 0,
        'adx': 20,
        'gamma': 0,
        'resonance': 3.5,
        'ema_cross': 0
    }

    def safe_get(val):
        return val if pd.notna(val) else 0

    indicators = {
        'rsi': safe_get(indicator_rsi(data).iloc[-1]),
        'macd': safe_get(indicator_macd(data).iloc[-1]),
        'obv': safe_get(indicator_obv(data).iloc[-1]),
        'ema_cross': safe_get(indicator_ema_cross(data).iloc[-1]),
        'atr': safe_get(indicator_atr(data).iloc[-1]),
        'adx': safe_get(indicator_adx(data).iloc[-1]),
        'cci': safe_get(indicator_cci(data).iloc[-1]),
        'bbw': safe_get(indicator_bbw(data).iloc[-1]),
        'vwap': safe_get(indicator_vwap(data).iloc[-1]),
        'fingerprint': safe_get(indicator_market_maker_fingerprint_instant(data).iloc[-1]),
        'gamma': safe_get(indicator_gamma(data).iloc[-1]),
        'liquidity': safe_get(indicator_liquidity(data).iloc[-1]),
        'hidden_liq': safe_get(indicator_hidden_liquidity(data).iloc[-1]),
        'resonance': indicator_fourier_resonance(data),
        'roc': safe_get(indicator_roc(data).iloc[-1]),
        'williams': safe_get(indicator_williams_r(data).iloc[-1]),
        'stoch': safe_get(indicator_stochastic(data).iloc[-1]),
        'turtle': safe_get(indicator_turtle_wave(data).iloc[-1])
    }

    for k in ['rsi', 'macd', 'adx', 'gamma', 'resonance', 'ema_cross']:
        if (k in thresholds) and (indicators[k] > thresholds[k]):
            score += 1

    close_price = safe_get(data['close'].iloc[-1])
    atr = indicators['atr']
    time_now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    reco_id = f"SPX-{int(datetime.now().timestamp())}"

    if atr < 15:
        return f"âš  Ø§Ù„Ø³ÙˆÙ‚ Ø¹Ø±Ø¶ÙŠ (ATR={atr:.2f})ØŒ Ù„Ø§ ØªØ¯Ø®Ù„ â€“ [{reco_id}] â€“ {time_now}"

    if score >= 5:
        strike = round(close_price + (atr * 2))
        price = 2.0
        return f"âœ… Ø¯Ø®ÙˆÙ„ ÙƒÙˆÙ„ Ù…Ù† {close_price:.2f} ÙˆØ§Ù„Ù‡Ø¯Ù {close_price + atr:.2f}ØŒ Ø§Ù„Ø¹Ù‚Ø¯ {strike} Ø¨Ø³Ø¹Ø± {price} Ø¯ÙˆÙ„Ø§Ø± â€“ [{reco_id}] â€“ {time_now}"
    elif score <= 2:
        strike = round(close_price - (atr * 2))
        price = 1.5
        return f"ğŸ”» Ø¯Ø®ÙˆÙ„ Ø¨ÙˆØª Ù…Ù† {close_price:.2f} ÙˆØ§Ù„Ù‡Ø¯Ù {close_price - atr:.2f}ØŒ Ø§Ù„Ø¹Ù‚Ø¯ {strike} Ø¨Ø³Ø¹Ø± {price} Ø¯ÙˆÙ„Ø§Ø± â€“ [{reco_id}] â€“ {time_now}"
    else:
        return f"ğŸš« Ø§Ù„Ø³ÙˆÙ‚ ØºÙŠØ± ÙˆØ§Ø¶Ø­ Ø§Ù„Ø¢Ù†ØŒ Ø§Ù„ØªØ±Ù‚Ø¨ Ø£ÙØ¶Ù„ â€“ [{reco_id}] â€“ {time_now}"

# --- Ø¥Ø±Ø³Ø§Ù„ ØªÙˆØµÙŠØ© Ø¥Ù„Ù‰ ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù… ---
def send_telegram_message(message):
    url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
    payload = {
        "chat_id": CHAT_ID,
        "text": message,
        "parse_mode": "Markdown"
    }
    requests.post(url, data=payload)

# --- Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ ---
if _name_ == "_main_":
    # Ø§Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† finnhub
    try:
        df = fetch_finnhub_ohlc(SYMBOL, limit=LIMIT, interval=INTERVAL)
        reco = decision_engine_full(df)
        send_telegram_message(reco)
        print("ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙˆØµÙŠØ© Ø¥Ù„Ù‰ ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù… Ø¨Ù†Ø¬Ø§Ø­.")
    except Exception as e:
        print("Ø­Ø¯Ø« Ø®Ø·Ø£:", e)Ø¨ÙˆØª
